# 基于 ReAct 的中长篇小说创作系统

## 概述

利用 ReAct 系统进行中长篇小说创作，充分利用以下特性。

**配置与 prompt**：小说创作相关的默认配置（字数、节奏、对话占比、token 限制等）与 prompt 模板（实体提取、JSON 修复、对话质量要求等）已集中到 **`config/novel`**，便于调整与复用。详见 `config/novel/README.md`。

- **工具动态发现**：Agent 可以主动查找工具文档
- **上下文缩减**：自动管理上下文，避免溢出
- **分层行动空间**：灵活使用 L1/L2/L3 工具
- **多 Agent 协作**：可选的多 Agent 协作模式

## 设计思路

### 1. 分章节创作

将长篇小说分解为多个章节，每章独立创作，降低上下文压力。

### 2. 上下文管理

- 每章完成后进行 Compaction，保留关键信息
- 使用章节摘要确保前后章节连贯性
- 每5章进行一次上下文压缩
- **续写时**（API 层 `run_continue`）：除上一章摘要外，会读取**上一章正文末尾约 1/5**（上限约 2000 字）注入 prompt，便于紧接情境与情绪；**更前章节**（第 1 章～第 N-2 章）传递大纲摘要 + 语义网格实体，保持人物与设定一致。`create_chapter` 支持参数 `previous_chapter_tail`、`earlier_chapters_summaries`。

### 3. 渐进式创作

支持边写边改，迭代优化。可以：
- 从任意章节开始续写
- 修改已有章节
- 调整大纲

### 4. 长期记忆注入（EverMemOS）

当配置 EverMemOS 云 API 时，`create_novel_plan` 与 `create_chapter` 支持可选参数 `extra_memory_context`：由 API 层在规划/续写前检索云端记忆并将结果传入。续写时使用**三类检索**（跨章人物、伏笔、长线设定）合并结果（`recall_three_types_from_evermemos`），与前端「跑检索测试」及脚本 `evermemos_retrieval_demo` 共用同一组查询，用于保持前后文与设定一致。

## 使用方法

### 基本使用

```python
from task.novel import ReactNovelCreator

# 创建小说创作器
creator = ReactNovelCreator(
    novel_title="时空旅者的日记",
    enable_context_offloading=True
)

# 创作小说
result = creator.create_novel(
    genre="科幻",
    theme="时间旅行、平行世界、人性探索",
    target_chapters=20,
    words_per_chapter=3000,
    start_from_chapter=1
)
```

### 分步创作

```python
# 1. 创建大纲
plan = creator.create_novel_plan(
    genre="科幻",
    theme="时间旅行",
    target_chapters=20,
    words_per_chapter=3000
)

# 2. 创作单个章节
chapter = creator.create_chapter(
    chapter_number=1,
    chapter_title="第一章：起点",
    chapter_summary="主角发现时间旅行的秘密",
    target_words=3000
)

# 3. 继续创作下一章
next_chapter = creator.create_chapter(
    chapter_number=2,
    chapter_title="第二章：第一次旅行",
    chapter_summary="主角进行第一次时间旅行",
    previous_chapters_summary=chapter.summary,  # 传递前面章节摘要
    target_words=3000
)
```

## 输出结构

```
task/novel/outputs/{novel_title}/
├── novel_plan.json          # 小说大纲
├── metadata.json            # 元数据
├── {novel_title}_完整版.txt # 完整小说
├── chapters/                # 章节文件
│   ├── chapter_001.txt
│   ├── chapter_001_meta.json
│   ├── chapter_002.txt
│   └── ...
├── summaries/               # 章节摘要
└── drafts/                  # 草稿
```

## 核心特性

### 1. 字数控制（基于番茄小说爆款数据统计）

- **目标字数**：2048字（完美落点）
- **允许范围**：1500-3000字
- **质量优先策略**：`max_new_tokens` 始终不低于 2048，字数控制通过 prompt 实现
- **智能截断**：超过3000字时自动截断，保留核心情节
- **字数优化**：初始生成使用较高 token 限制（3072），字数控制通过 prompt 实现；重写时根据原始字数进行优化或补充

### 2. 情节节奏控制

每章按照以下节奏结构创作：
- **开头（约25%）**：快速进入情节，引入本章核心冲突
- **发展（约40%）**：展开情节，推进冲突，展现人物
- **高潮（约25%）**：冲突达到顶点或出现转折
- **结尾（约10%）**：自然过渡，为下一章埋下伏笔

### 3. 对话质量优化

- **对话占比**：20-40%（确保平衡）
- **对话功能**：推进情节、展现人物、制造冲突、提供信息
- **对话风格**：保持角色语言风格一致
- **对话技巧**：避免信息转储，使用潜台词，结合动作描写

### 4. 上下文管理

- 自动使用 Context Offloading 管理上下文
- 每章完成后生成摘要，用于后续章节连贯性
- 每5章进行一次上下文压缩
- **分层摘要系统**：最近章节摘要、阶段摘要、关键节点摘要

### 5. 章节连贯性

- 使用前面章节的摘要保持连贯性
- 自动检查人物性格一致性
- 保持情节逻辑连贯
- **实体管理系统**：
  - 实体重要性评分：根据出现频率和上下文重要性评分
  - 分层传递：重要实体优先传递到后续章节
  - **多模型投票提取**：使用多个LLM（`kimi_k2` + `gemini_3_flash`）进行投票提取，精度95%+
  - **主模型优先策略**：优先保留 Kimi K2 的所有提取结果，避免损失优秀结果
  - Gemini 提取的实体作为补充（如果 Kimi 没有提取到）
  - 自动去重和合并相似实体

### 6. 质量监控与优化

#### 6.1 单章质量检查

每章完成后自动进行全面的质量检查：

- **一致性检查**：角色一致性、世界观一致性、时间线一致性、情节逻辑一致性
- **对话质量检查**：
  - 对话占比（目标20-40%）
  - 对话目的（推进情节、展现人物、制造冲突）
  - 对话风格（角色语言风格一致性）
  - 对话与动作结合（避免纯对话堆砌）
- **描述质量检查**：
  - 冗余环境描述检测
  - 过度心理活动检测（限制：全章不超过10句）
  - 描述与情节推进的平衡

#### 6.2 阶段性质量检查

每10章进行一次综合质量评估：

- **连贯性得分**：章节间的逻辑连贯性
- **人物一致性得分**：人物性格、行为的一致性
- **情节节奏得分**：基于字数方差和对话比率的节奏评估
- **世界观一致性得分**：世界观设定的统一性
- **悬念得分**：使用 **LLM（deepseek_v3_2）** 进行智能评估
  - 评估维度：情节悬念、氛围营造、结尾设计、心理描写、信息控制
  - 相比关键词匹配，能更准确识别深层悬疑元素
- **综合评分**：综合所有维度（低于0.7时触发警告）

#### 6.3 智能重写机制（Phase 1 & 2 优化）

当检测到严重质量问题时会自动触发重写：

- **触发条件**：
  - 严重问题数 >= 1，或
  - 总问题数 >= 3
- **渐进式修复**：
  - 每次只修复1-2个最高优先级问题
  - 优先选择历史成功率更高的问题
  - 综合考虑预测成功率和优先级（评分公式：成功率 × 0.7 + 优先级权重 × 0.3）
- **智能问题选择**：
  - 所有候选问题按预测成功率排序
  - 动态阈值：第一轮 >= 0.4，后续轮 >= 0.3
  - 如果没有满足阈值的问题，选择成功率最高的1个
- **精准修复策略**：
  - 从修复策略库获取针对性的修复提示
  - 根据问题类型和历史成功率选择最佳策略
  - 包含针对性的修复方法和 few-shot 示例
- **自适应重试机制**：
  - 当一种策略失败时，自动尝试备用策略
  - 从预测器中获取 `alternative_strategy`
  - 记录策略尝试历史，避免重复尝试失败的策略
- **修复验证**：
  - 使用修复验证器验证修复效果
  - 避免0.00评分，更准确反映改善程度
  - 所有验证评分至少为0.1-0.2，避免误判
- **安全重写模式**：
  - 如果重写后问题数增加，回退到原始内容
  - 如果重写后引入了新类型的问题，回退
  - 只接受问题数减少或不变的重写结果
- **重写策略**：
  - 基于质量检查反馈构建重写提示词
  - 保持核心情节和主要事件不变
  - 解决检测到的质量问题
  - 重写后重新进行质量检查
- **效果追踪**：记录重写前后的质量对比

#### 6.4 动态调整机制

根据质量反馈动态调整后续章节的生成策略：

- **节奏问题调整**：当节奏得分 < 0.7 时，增强节奏控制指令
- **悬念问题调整**：当悬念得分 < 0.7 时，强化悬念设置要求
- **对话问题调整**：当对话占比或质量不达标时，优化对话要求
- **描述问题调整**：当检测到冗余描述或过度心理活动时，限制描述篇幅
- **一致性问题调整**：当检测到一致性问题时，强化一致性检查

#### 6.5 自适应生成策略

根据质量反馈自动调整生成参数：

- **连贯性增强**：当连贯性得分低时，增强连贯性检查
- **节奏控制**：当节奏得分低时，启用节奏控制
- **悬念控制**：当悬念得分低时，启用悬念控制
- **动态字数调整**：根据历史平均字数动态调整目标字数

### 7. 渐进式大纲（100+章节）

- **整体大纲**：100-200章的整体故事框架
- **阶段大纲**：每20章一个阶段，详细规划
- **章节大纲**：每章的具体内容摘要
- 支持动态生成阶段大纲，避免一次性生成所有章节大纲
- **续写触发扩展**：续写时若下一章为新阶段首章（如第 21 章）且该阶段大纲未生成，会先调用 `_generate_phase_outline` 生成该阶段（如 21–40 章）并写入 `novel_plan.json`，再按新大纲写；创建新作时可传 `use_progressive=False` 一次性生成全部章节大纲

### 8. 灵活创作

- 支持从任意章节开始续写
- 支持修改已有章节
- 支持调整大纲

## LLM 配置

系统采用混合模型策略，根据任务特点选择最适合的模型（基于实际对比测试结果）：

### 1. 章节生成

- **模型**：`gemini_3_flash`（默认，推荐）
- **原因**：
  - 字数控制更准确（差异27.1% vs 135.9%）
  - 初始质量问题更少（1.30 vs 2.40个/章）
  - 需要重写的章节更少（50% vs 70%）
- **配置方式**：
  - 环境变量：`export NOVEL_LLM_MODEL=gemini_3_flash`
  - 代码参数：`ReactNovelCreator(llm_client=gemini_3_flash)`

### 2. 重写机制

- **模型**：使用章节生成相同的模型（`gemini_3_flash`）
- **原因**：
  - 重写改善率更高（60.0% vs 57.1%）
  - 平均重写轮数相当（2.60 vs 2.57）
- **实现**：通过 `self.agent.run()` 调用，自动使用传入的 `llm_client`

### 3. 悬念评估

- **模型**：`deepseek_v3_2`（固定）
- **原因**：
  - 更适合深度理解和分析任务
  - 能够准确识别深层悬疑元素
- **实现**：`_calculate_suspense_score()` 方法中固定使用

### 4. 实体提取

- **模型**：多模型投票（`kimi_k2` + `gemini_3_flash`）
- **原因**：
  - Kimi K2 实体提取能力最强（7种类型，18-25个实体/章）
  - Gemini 3 Flash 作为验证和补充，提高提取精度
  - **优先保留策略**：优先保留 Kimi 的所有提取结果，避免损失优秀结果
  - Gemini 提取的实体作为补充（如果 Kimi 没有提取到）
- **实现**：`MultiModelEntityExtractor` 类（主模型优先策略）
- **策略说明**：
  - 主模型（Kimi）提取的所有实体都保留
  - 辅助模型（Gemini）提取的实体作为补充
  - 多个模型都提取到的实体，合并描述提高质量

### 5. 质量检查

- **方法**：基于规则的检查系统
- **说明**：不直接使用LLM，通过规则检查一致性、连贯性、风格等问题

### 配置变更历史

#### 2026-01-22
- **变更**：实体提取模型从 `gemini_3_flash + deepseek_v3_2` 改为 `kimi_k2 + gemini_3_flash`
- **依据**：Kimi K2 实体提取能力最强（7种类型，18-25个实体/章），字数控制最佳（13.1%偏差）
- **变更**：实施质量优先策略，`max_new_tokens` 始终不低于 2048
- **变更**：实施 Phase 1 & 2 优化（渐进式修复、历史学习、效果预测、自适应重试）

#### 2026-01-21
- **变更**：默认章节生成模型从 `deepseek_v3_2` 改为 `gemini_3_flash`
- **依据**：LLM对比测试结果

### 使用建议

1. **默认配置**：直接使用，无需修改（已优化为最佳配置）
2. **自定义配置**：可通过环境变量 `NOVEL_LLM_MODEL` 临时切换
3. **评估任务**：不建议修改悬念评估和质量评估的模型配置
4. **实体提取**：保持多模型投票，确保高精度

## 优化功能

### Phase 1: 基础优化（已完成 ✅）

1. **字数控制**：基于番茄小说爆款数据统计，目标2048字，上限3000字
2. **实体管理系统**：实体重要性评分、分层传递、多模型投票提取
3. **渐进式大纲**：三层次大纲（整体、阶段、章节），支持100+章节
4. **分层摘要**：最近章节摘要、阶段摘要、关键节点摘要

### Phase 2: 质量优化（已完成 ✅）

1. **情节节奏控制**：开头25%、发展40%、高潮25%、结尾10%
2. **对话质量优化**：对话占比20-40%，确保对话推进情节
3. **阶段性质量检查**：每10章自动评估综合质量（连贯性、人物一致性、节奏、世界观、悬念）

### Phase 3: 高级优化（已完成 ✅）

1. **质量指标追踪**：持续追踪所有质量指标（字数、对话占比、质量问题等）
2. **LLM悬念评估**：使用 deepseek_v3_2 进行智能悬念得分评估，替代关键词匹配
3. **章节重写机制**：基于质量反馈自动重写问题章节
4. **动态调整指令**：根据质量问题类型（节奏、悬念、对话、描述、一致性）动态调整后续章节prompt
5. **自适应生成策略**：根据质量反馈自动调整生成参数和策略
6. **质量追踪系统**：完整记录每章的质量指标，支持质量趋势分析

### Phase 4: 智能重写优化（已完成 ✅）

1. **渐进式修复**：每次只修复1-2个最高优先级问题，避免一次性修复过多问题
2. **修复策略库**：针对不同问题类型定义专门的修复策略、提示词和 few-shot 示例
3. **修复验证器**：验证修复是否真正解决了目标问题，检查是否引入新问题
4. **修复历史学习**：记录修复尝试和结果，用于优化未来策略选择
5. **修复效果预测**：基于历史数据预测修复成功率，避免无效重写
6. **智能问题选择**：优先选择历史成功率更高的问题，综合考虑预测成功率和优先级
7. **精准修复策略**：整合修复策略库到重写 prompt，提供针对性的修复方法和示例
8. **自适应重试机制**：当一种策略失败时，自动尝试备用策略
9. **验证逻辑优化**：避免0.00评分，更准确反映改善程度，所有验证评分至少为0.1-0.2

## 重写机制说明

### 触发条件

- **严重问题数 >= 1**，或
- **总问题数 >= 3**

### 重写流程

1. **问题选择**：
   - 按优先级分组：一致性 > 对话 > 描述 > 其他
   - 计算每个问题的预测成功率
   - 综合考虑成功率和优先级，选择1-2个问题
   - 动态阈值：第一轮 >= 0.4，后续轮 >= 0.3

2. **策略选择**：
   - 从修复策略库获取针对性的修复策略
   - 如果上一轮失败，自动尝试备用策略（自适应重试）
   - 根据问题类型和历史成功率选择最佳策略

3. **重写执行**：
   - 使用精准的修复提示词（包含 few-shot 示例）
   - 保持核心情节和主要事件不变
   - 只修改检测到的具体问题

4. **修复验证**：
   - 使用修复验证器验证修复效果
   - 计算验证评分（避免0.00，至少0.1-0.2）
   - 检查是否引入新问题

5. **质量保护**：
   - 如果重写后问题数增加，回退到原始内容
   - 如果重写后引入了新类型的问题，回退
   - 只接受问题数减少或不变的重写结果

6. **历史学习**：
   - 记录修复尝试和结果
   - 更新策略成功率
   - 用于优化未来策略选择

### 重写策略类型

- **CONSERVATIVE**：保守修复，最小改动
- **AGGRESSIVE**：激进修复，彻底重构
- **SURGICAL**：精准修复，针对特定问题
- **ITERATIVE**：迭代修复，逐步改进

### 重写停止条件

- 改善 >= 50% 或问题数 <= 1：停止重写（效果优秀）
- 改善 >= 30% 且重写轮次 >= 2：停止重写（效果良好）
- 改善 <= 0 且重写轮次 >= 3：停止重写（已尝试3轮）
- 改善 <= 0 且重写轮次 == 2：继续第3轮（尝试备用策略）

## 实体提取改进

### Kimi 实体提取优势

1. **分类更细致**：7大类（人物、组织、地点、物品、生物、概念、时间）vs 当前3类
2. **提取更全面**：18-25个实体/章，包含概念、规则、时间等抽象实体
3. **描述更详细**：包含括号内的关键信息补充
4. **结构化输出**：按类别分组，已去重

### 多模型投票策略

- **主模型（Kimi K2）**：优先保留所有提取结果
- **辅助模型（Gemini 3 Flash）**：作为验证和补充
- **投票机制**：多个模型都提取到的实体，合并描述提高质量
- **提取精度**：95%+

## 测试结果

### 阶段性质量检查示例（12章测试）

```json
{
  "chapter_range": "第1-10章",
  "scores": {
    "coherence": 1.00,
    "character_consistency": 1.00,
    "plot_rhythm": 0.60,
    "worldview_consistency": 1.00,
    "suspense": 0.80,
    "overall": 0.90
  },
  "needs_attention": false
}
```

**评分说明**：
- 综合评分 0.90（优秀）
- 连贯性、人物一致性、世界观一致性均为满分
- 节奏得分 0.60（需要改进，章节长度变化较小）
- 悬念得分 0.80（良好，使用LLM评估）

**质量优化效果**：
- 系统会自动检测到节奏和悬念问题
- 动态调整后续章节的生成策略
- 问题章节会自动触发重写机制
- 质量指标持续追踪，支持趋势分析

### 重写机制优化效果

**Phase 1 & 2 优化前**：
- 重写改善率：16.7%（1/6章改善）
- 验证评分：平均0.20，最低0.00

**Phase 1 & 2 优化后**：
- 重写改善率：50.0%（4/8章改善）
- 验证评分：平均0.29，最低0.10（消除0.00评分）

**系统优化后（智能问题选择 + 精准修复策略）**：
- 重写改善率：66.7%（4/6章改善）
- 验证评分：平均0.51，最低0.15（显著提升）
- 智能问题选择：平均预测成功率0.54

## 与 UniMem 的集成（未来）

当前版本不使用 UniMem，但设计上已考虑未来集成：

- 章节内容可以存储到 UniMem
- 人物信息可以存储到 UniMem
- 情节线索可以存储到 UniMem
- 使用 UniMem 检索相关章节和人物信息

## 注意事项

1. **LLM 配置**：确保 `orchestrator/react.py` 中的 LLM 配置正确，支持通过环境变量 `NOVEL_LLM_MODEL` 指定模型
2. **上下文长度**：长篇小说创作时注意上下文长度管理，系统会自动进行压缩
3. **创作质量**：系统自动进行质量检查，每10章生成质量报告，问题章节会自动重写
4. **资源消耗**：长篇小说创作需要较多 Token，注意成本控制
   - 悬念评估：每5章评估一次，每次调用 deepseek_v3_2
   - 重写机制：仅在检测到严重问题时触发
5. **字数控制**：虽然目标2048字，但实际可能在2500-3000字之间（符合番茄小说统计建议）
6. **质量优化**：系统会自动根据质量反馈调整后续章节，无需手动干预
7. **质量优先策略**：`max_new_tokens` 始终不低于 2048，字数控制通过 prompt 实现，如果内容优质，字数可以适当浮动（±20%以内都可以接受）

## 示例与脚本

- **质量优化测试**（本目录）：`python -m task.novel.test_quality_optimizations`（需在 `src` 下执行）
- **100 章创作、后台运行、测试监控脚本**：见 **`scripts/novel/README.md`**（非主路径，主路径为前端 + `/api/creator/stream`）
